<!doctype html>

<html lang="en">
  <head>
    <title>Life</title>
    <meta name="description" content="Life">
    <meta name="author" content="God">
    <style>
      body {
	  background-color:#cccccc;
	  text-align: center;
      }
      #grid{
	  width: 1000px;
	  margin: 0 auto;
      }
    </style>
  </head>

  <body>
    <div id="grid"></div>
    <button id="next">Next generation</button>
    <button id="auto">Auto</button>
  </body>
  <script>
    /* 
     Generations are represented with arrays of 1s and 0s, where 1 is a live
     cell and 0 a dead cell.
     
     Generations are displayed in a grid of checkboxes, where a checked checkbox
     is a live cell and an unchecked checkbox is a dead cell.

     Rules:
     Any live cell with fewer than two or more than three live neighbors dies.
     Any live cell with two or three live neighbors lives on to the next generation.
     Any dead cell with exactly three live neighbors becomes a live cell.
     
     To decide what will happen to a cell we need a method to find its
     neighbors. This is my method. The following are the neighbors of a cell
     `cell`, in a grid n x n:

     cell + 1. Unless cell is in the last column.

     cell -1. Unless cell is in the first column.

     cell + (n - 1). Unless cell is in the first column or in the last row.

     cell - (n - 1). Unless cell is in the first row or in the last column.

     cell + n. Unless cell is in the last row.

     cell - n. Unless cell is in the first row.

     cell + (n + 1). Unless cell is in the last column or in the last row.

     cell - (n + 1) Unless cell is in the first row or in the first column.

     */


   // Create grid
   createGrid();

   // Create life
   let currentGeneration = life();
   updateGrid(currentGeneration);

   let nextButton = document.getElementById('next');
   nextButton.addEventListener('click', () => {
       currentGeneration = nextGeneration(currentGeneration);
       updateGrid(currentGeneration);
   });

   let autoButton = document.getElementById('auto');
   autoButton.addEventListener('click', () => {
       setInterval(() => {
	   currentGeneration = nextGeneration(currentGeneration);
	   updateGrid(currentGeneration);
       }, 200);
   });

   // Take generation, return next generation.
   function nextGeneration(current, n = 40) {
       let next = [];

       for (let x = 0; x < n; x++) {
	   for (let y = 0; y < n; y++) {
	       let cell = x*n + y;
	       if (x === n) {
		   if (y === n) { // if it's last row and last column
		       neighborIndexes = [cell - 1, cell - n, cell - (n + 1)];
		       neighborValues = values(current, neighborIndexes);
		       next.push(updateCell(current[cell], neighborValues));
		   } else if (y === 0) { // if it's first row and last column
		       neighborIndexes = [cell -1, cell + (n -1), cell + n];
		       neighborValues = values(current, neighborIndexes);;
		       next.push(updateCell(current[cell], neighborValues));
		   } else { // if it's only last column
		       neighborIndexes = [cell - 1, cell + (n - 1), cell + n, cell - n, cell - (n + 1)];
		       neighborValues = values(current, neighborIndexes);;
		       next.push(updateCell(current[cell], neighborValues));
		   }
	       } else if (x === 0) {
		   if (y === 0) { // if it's first row and first column
		       neighborIndexes = [cell + 1, cell + n, cell + (n +1)];
		       neighborValues = values(current, neighborIndexes);;
		       next.push(updateCell(current[cell], neighborValues));
		   } else if (y === n) { // if it's last row and first column
		       neighborIndexes = [cell + 1, cell - (n - 1), cell - n];
		       neighborValues = values(current, neighborIndexes);;
		       next.push(updateCell(current[cell], neighborValues));
		   } else { // if it's first column
		       neighborIndexes = [cell + 1, cell - (n -1), cell + n, cell - n, cell + (n + 1)];
		       neighborValues = values(current, neighborIndexes);;
		       next.push(updateCell(current[cell], neighborValues));
		   }
	       } else if (y === n) { // if it's last row
		   neighborIndexes = [cell + 1, cell -1, cell - (n - 1), cell -n, cell - (n + 1)];
		   neighborValues = values(current, neighborIndexes);;
		   next.push(updateCell(current[cell], neighborValues));
	       } else if (y === 0) { // if it's first row
		   neighborIndexes = [cell + 1, cell - 1, cell + (n - 1), cell + n, cell + (n + 1)];
		   neighborValues = values(current, neighborIndexes);;
		   next.push(updateCell(current[cell], neighborValues));
	       } else { // if it's neither first/last column, nor first/last row
		   neighborIndexes = [cell + 1, cell -1, cell + (n - 1), cell - (n - 1), cell + n, cell - n,
				      cell + (n + 1), cell - (n + 1)];
		   neighborValues = values(current, neighborIndexes);;
		   next.push(updateCell(current[cell], neighborValues));
	       }
	   }
       }
       return next;
   }

   // Take cell (0 or 1) and array of neighbors (0s and 1s), return updated cell.
   function updateCell(cell, neighbors) {
       let liveNeighbors = 0;
       for (n of neighbors)
	   if (n === 1)
	       liveNeighbors++;

       if (cell === 1) {
	   if (liveNeighbors < 2 || liveNeighbors > 3)
	       return 0; // cell dies :(
	   else if (liveNeighbors === 2 || liveNeighbors == 3)
	       return 1; // cell keeps surviving :)
       } else if (cell === 0) {
	   if (liveNeighbors === 3)
	       return 1; // cell becomes alive :O
	   else
	       return 0;
       }
   }

   // Take array of values and an array of indexes of those values.
   // Return array of the values of those indexes.
   // Example: 
   // [a, b, c], [0, 2] => [a, c]
   function values(array, indexes) {
       let result = [];
       for (let i = 0; i < indexes.length; i++) {
	   result.push(array[indexes[i]]);
       }
       return result;
   }

   // Take generation. Change grid accordingly.
   function updateGrid(generation, rows = 40) {
       if (generation.length !== rows * rows) console.log('Error 1');
       let cells = Array.from(document.querySelectorAll('input'));
       for (let i = 0; i < generation.length; i++) {
	   if (generation[i] === 1) {
	       cells[i].checked = 'true';
	   } else {
	       cells[i].checked = '';
	   }
       }
   }

   // Create grid of checkboxes.
   function createGrid(rows = 40) {
       let grid = document.querySelector('#grid');
       grid.innerHTML = ''; // remove old cells
       for (let i = 0; i < rows; i++) {
	   let div = document.createElement('div');
	   for (let i = 0; i < rows; i++) {
	       let checkbox = document.createElement('input');
	       checkbox.type = 'checkbox';
	       div.appendChild(checkbox);
	   }
	   grid.appendChild(div);
       }
   }

   // Return random generation.
   function life(rows = 40) {
       let totalCellNumber = rows * rows; 
       let gen = [];
       for (let i = 0; i < totalCellNumber; i++) {
	   if (Math.random() > 0.9) gen.push(1);
	   else gen.push(0);
       }
       return gen;
   }
  </script>
</html>
